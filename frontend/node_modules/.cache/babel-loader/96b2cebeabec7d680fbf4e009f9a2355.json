{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useRef, useState } from 'react';\nconst useVideoRecorder = () => {\n  _s();\n  const [isRecording, setIsRecording] = useState(false);\n  const mediaRecorderRef = useRef(null);\n  const recordedChunksRef = useRef([]);\n  const stopResolverRef = useRef(null);\n  useEffect(() => {\n    const initMediaRecorder = async () => {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        video: true\n      });\n      const recorder = new MediaRecorder(stream);\n      recorder.ondataavailable = event => {\n        if (event.data.size > 0) {\n          recordedChunksRef.current.push(event.data);\n        }\n      };\n      recorder.onstop = () => {\n        const chunks = recordedChunksRef.current;\n        const videoBlob = chunks.length ? new Blob(chunks, {\n          type: 'video/webm'\n        }) : null;\n        if (stopResolverRef.current) {\n          stopResolverRef.current(videoBlob);\n          stopResolverRef.current = null;\n        }\n        recordedChunksRef.current = [];\n      };\n      mediaRecorderRef.current = recorder;\n    };\n    initMediaRecorder();\n    return () => {\n      if (mediaRecorderRef.current) {\n        mediaRecorderRef.current.stream.getTracks().forEach(track => track.stop());\n      }\n    };\n  }, []);\n  const startRecording = () => {\n    const recorder = mediaRecorderRef.current;\n    if (recorder) {\n      recordedChunksRef.current = [];\n      recorder.start();\n      setIsRecording(true);\n    }\n  };\n  const stopRecording = () => {\n    return new Promise(resolve => {\n      const recorder = mediaRecorderRef.current;\n      if (!recorder) {\n        resolve(null);\n        return;\n      }\n      stopResolverRef.current = resolve;\n      recorder.stop();\n      setIsRecording(false);\n    });\n  };\n  return {\n    isRecording,\n    startRecording,\n    stopRecording\n  };\n};\n_s(useVideoRecorder, \"KfN3pol2It1v6TwGr3jv55gGf1M=\");\nexport default useVideoRecorder;","map":{"version":3,"names":["useEffect","useRef","useState","useVideoRecorder","_s","isRecording","setIsRecording","mediaRecorderRef","recordedChunksRef","stopResolverRef","initMediaRecorder","stream","navigator","mediaDevices","getUserMedia","video","recorder","MediaRecorder","ondataavailable","event","data","size","current","push","onstop","chunks","videoBlob","length","Blob","type","getTracks","forEach","track","stop","startRecording","start","stopRecording","Promise","resolve"],"sources":["/Users/mohamedhosam/Documents/GradProject/UniFreelance/frontend/src/hooks/useVideoRecorder.ts"],"sourcesContent":["import { useEffect, useRef, useState } from 'react';\n\nconst useVideoRecorder = () => {\n    const [isRecording, setIsRecording] = useState<boolean>(false);\n    const mediaRecorderRef = useRef<MediaRecorder | null>(null);\n    const recordedChunksRef = useRef<Blob[]>([]);\n    const stopResolverRef = useRef<((blob: Blob | null) => void) | null>(null);\n\n    useEffect(() => {\n        const initMediaRecorder = async () => {\n            const stream = await navigator.mediaDevices.getUserMedia({ video: true });\n            const recorder = new MediaRecorder(stream);\n\n            recorder.ondataavailable = (event) => {\n                if (event.data.size > 0) {\n                    recordedChunksRef.current.push(event.data);\n                }\n            };\n\n            recorder.onstop = () => {\n                const chunks = recordedChunksRef.current;\n                const videoBlob = chunks.length ? new Blob(chunks, { type: 'video/webm' }) : null;\n                if (stopResolverRef.current) {\n                    stopResolverRef.current(videoBlob);\n                    stopResolverRef.current = null;\n                }\n                recordedChunksRef.current = [];\n            };\n\n            mediaRecorderRef.current = recorder;\n        };\n\n        initMediaRecorder();\n\n        return () => {\n            if (mediaRecorderRef.current) {\n                mediaRecorderRef.current.stream.getTracks().forEach(track => track.stop());\n            }\n        };\n    }, []);\n\n    const startRecording = () => {\n        const recorder = mediaRecorderRef.current;\n        if (recorder) {\n            recordedChunksRef.current = [];\n            recorder.start();\n            setIsRecording(true);\n        }\n    };\n\n    const stopRecording = () => {\n        return new Promise<Blob | null>((resolve) => {\n            const recorder = mediaRecorderRef.current;\n            if (!recorder) {\n                resolve(null);\n                return;\n            }\n            stopResolverRef.current = resolve;\n            recorder.stop();\n            setIsRecording(false);\n        });\n    };\n\n    return { isRecording, startRecording, stopRecording };\n};\n\nexport default useVideoRecorder;\n"],"mappings":";AAAA,SAASA,SAAS,EAAEC,MAAM,EAAEC,QAAQ,QAAQ,OAAO;AAEnD,MAAMC,gBAAgB,GAAGA,CAAA,KAAM;EAAAC,EAAA;EAC3B,MAAM,CAACC,WAAW,EAAEC,cAAc,CAAC,GAAGJ,QAAQ,CAAU,KAAK,CAAC;EAC9D,MAAMK,gBAAgB,GAAGN,MAAM,CAAuB,IAAI,CAAC;EAC3D,MAAMO,iBAAiB,GAAGP,MAAM,CAAS,EAAE,CAAC;EAC5C,MAAMQ,eAAe,GAAGR,MAAM,CAAuC,IAAI,CAAC;EAE1ED,SAAS,CAAC,MAAM;IACZ,MAAMU,iBAAiB,GAAG,MAAAA,CAAA,KAAY;MAClC,MAAMC,MAAM,GAAG,MAAMC,SAAS,CAACC,YAAY,CAACC,YAAY,CAAC;QAAEC,KAAK,EAAE;MAAK,CAAC,CAAC;MACzE,MAAMC,QAAQ,GAAG,IAAIC,aAAa,CAACN,MAAM,CAAC;MAE1CK,QAAQ,CAACE,eAAe,GAAIC,KAAK,IAAK;QAClC,IAAIA,KAAK,CAACC,IAAI,CAACC,IAAI,GAAG,CAAC,EAAE;UACrBb,iBAAiB,CAACc,OAAO,CAACC,IAAI,CAACJ,KAAK,CAACC,IAAI,CAAC;QAC9C;MACJ,CAAC;MAEDJ,QAAQ,CAACQ,MAAM,GAAG,MAAM;QACpB,MAAMC,MAAM,GAAGjB,iBAAiB,CAACc,OAAO;QACxC,MAAMI,SAAS,GAAGD,MAAM,CAACE,MAAM,GAAG,IAAIC,IAAI,CAACH,MAAM,EAAE;UAAEI,IAAI,EAAE;QAAa,CAAC,CAAC,GAAG,IAAI;QACjF,IAAIpB,eAAe,CAACa,OAAO,EAAE;UACzBb,eAAe,CAACa,OAAO,CAACI,SAAS,CAAC;UAClCjB,eAAe,CAACa,OAAO,GAAG,IAAI;QAClC;QACAd,iBAAiB,CAACc,OAAO,GAAG,EAAE;MAClC,CAAC;MAEDf,gBAAgB,CAACe,OAAO,GAAGN,QAAQ;IACvC,CAAC;IAEDN,iBAAiB,CAAC,CAAC;IAEnB,OAAO,MAAM;MACT,IAAIH,gBAAgB,CAACe,OAAO,EAAE;QAC1Bf,gBAAgB,CAACe,OAAO,CAACX,MAAM,CAACmB,SAAS,CAAC,CAAC,CAACC,OAAO,CAACC,KAAK,IAAIA,KAAK,CAACC,IAAI,CAAC,CAAC,CAAC;MAC9E;IACJ,CAAC;EACL,CAAC,EAAE,EAAE,CAAC;EAEN,MAAMC,cAAc,GAAGA,CAAA,KAAM;IACzB,MAAMlB,QAAQ,GAAGT,gBAAgB,CAACe,OAAO;IACzC,IAAIN,QAAQ,EAAE;MACVR,iBAAiB,CAACc,OAAO,GAAG,EAAE;MAC9BN,QAAQ,CAACmB,KAAK,CAAC,CAAC;MAChB7B,cAAc,CAAC,IAAI,CAAC;IACxB;EACJ,CAAC;EAED,MAAM8B,aAAa,GAAGA,CAAA,KAAM;IACxB,OAAO,IAAIC,OAAO,CAAeC,OAAO,IAAK;MACzC,MAAMtB,QAAQ,GAAGT,gBAAgB,CAACe,OAAO;MACzC,IAAI,CAACN,QAAQ,EAAE;QACXsB,OAAO,CAAC,IAAI,CAAC;QACb;MACJ;MACA7B,eAAe,CAACa,OAAO,GAAGgB,OAAO;MACjCtB,QAAQ,CAACiB,IAAI,CAAC,CAAC;MACf3B,cAAc,CAAC,KAAK,CAAC;IACzB,CAAC,CAAC;EACN,CAAC;EAED,OAAO;IAAED,WAAW;IAAE6B,cAAc;IAAEE;EAAc,CAAC;AACzD,CAAC;AAAChC,EAAA,CA9DID,gBAAgB;AAgEtB,eAAeA,gBAAgB","ignoreList":[]},"metadata":{},"sourceType":"module"}